//This is a library app, mostly for the draw command, which allows to import these shape-drawing functions into your own app.
//Arguments for each are to be given as a singleton list, for ease of use. This is with the exception of the fill_flat functions, with
//the assumption that they're unlikely to be used outside of internal calls, but it is still available to be called if necessary.
//Make sure you read the arguments and input them in the correct order, or it will mess up.
//these functions return a set of all the positions in the shape, given the parameters, without repeating a position.
//This way, you can efficiently iterate over the positions once having generated them. See draw_beta.sc for an example. todo change to draw once renamed


//Basically using Bresenham circle algorithm to draw the sphere as a bunch of circles.
//This still has some issues, but it works better than the previous solution
//todo update this when I figure out how to properly generalize Bresenham circle logic to 3D
draw_sphere(args)->(
    [centre, radius, hollow] = args;
    positions = {};
    [cx,cy,cz]=centre;
	r = floor(radius);
	x=0;
	z=r;
	d = 1.25-r;
	while(x<=z, r,
		positions = positions + fill_flat_circle(centre, x, z, 'y', hollow, true);
		positions = positions + fill_flat_circle(centre,-x, z, 'y', hollow, true);
		positions = positions + fill_flat_circle(centre, z, x, 'y', hollow, true);
		positions = positions + fill_flat_circle(centre,-z, x, 'y', hollow, true);
		if(d>0,
			d+=2*x-2*z+5;
			z=z-1,
			d+=2*x+3
		);
		x+=1;
	);

    positions
);

draw_diamond(args)->(
    [pos, radius] = args;
    positions = {};
    c_for(r=0, r<radius, r+=1,
        y = r-radius+1;
        c_for(x=-r,x<=r,x+=1,
            z=r-abs(x);
            positions += [pos:0+x, pos:1 +y, pos:2+z];
            positions += [pos:0+x, pos:1 +y, pos:2-z];
            positions += [pos:0+x, pos:1 -y, pos:2+z];
            positions += [pos:0+x, pos:1 -y, pos:2-z];
        )
    );
    positions
);

draw_filled_diamond(args)->(
    [pos, radius] = args;
    positions = {};
    for(diamond(pos,radius,radius),
        positions += pos(_)
    );
    positions
);

draw_pyramid(args)->(
    [pos, radius, height, pointing, orientation, fill_type, is_square] = args;
    positions = {};
    hollow = fill_type=='hollow';
    pointup = pointing=='up';
    for(range(height),
        r = if(pointup, radius * ( 1- _ / height) -1, radius * _ / height);
        positions = positions + fill_flat(pos, _, r, is_square, orientation, !((pointup&&_==0)||(!pointup && _==height-1)) && hollow)//Always close bottom off
    );
    positions
);

draw_prism(args)->(
    [pos, rad, height, orientation, fill_type, is_square]=args;
    positions = {};
    hollow = fill_type =='hollow';
    radius = rad+0.5;
    filled_circle_points = fill_flat(pos, 0, radius, is_square, orientation, false); //I dont actually need to generate all the points lol
    offset_vector = if(orientation=='x', [1,0,0], orientation=='y', [0,1,0],[0,0,1]);
    if(hollow,
        hollow_circle_points = fill_flat(pos, 0, radius, is_square, orientation, true);

        for(filled_circle_points,//Always close ends off
            positions+=_;
            positions+=_+offset_vector*(height-1)
        );

        for(range(1, height-1),//cos Im adding ends as filled anyways
            offset=_;
            for(hollow_circle_points,
                positions+= _ + offset_vector * offset
            )
        ),

        for(range(height),
            offset = _;
            for(filled_circle_points,
                positions += _ + offset_vector * offset
            )
        );
    );
    positions
);

fill_flat(pos, offset, dr, rectangle, orientation, hollow)->
    if(rectangle,
        fill_flat_rectangle(pos, offset, dr, orientation, hollow),
        fill_flat_circle(pos, offset, dr, orientation, hollow, true)
    );

//Bresenham circle algorithm to be super efficient
//This is a modified verison from here: https://weber.itn.liu.se/~stegu76/circle/circlealgorithm.pdf
//That paper goes into a lot more detail on how to make it faster, but in scarpet it changes nothing
//Cos the optimizations are essentially to only use integer maths which is faster,
//but scarpet uses floating point maths anyways.
//But there is room for less calculation, by avoiding to recalculate (x+1)^2+(y-1/2)^2 every time
//Also, the original algorithm generates a thin circle,
//which means that cones and spheres have gaps between the layers.
//To solve, I plot an extra point if we're moving diagonally downwards, and that solves the issue entirely.
//But this caused other issues, so I added the 'thick' parameter to choose between the two options.
fill_flat_circle(pos, offset, dr, orientation, hollow, thick) ->(

    r = floor(dr);

	positions = {};

    if(r == 0,
        offset_vector = if(orientation=='x', [1,0,0], orientation=='y', [0,1,0],[0,0,1]);
        positions += pos + offset_vector*offset;
        return(positions)
    );

    a=0;
    b=r;
	d = 1.25-r;

    while(a<=b, r, //technically the limit is r/sqrt(2) but whatevs
		positions = positions + fill_flat_circle_points(pos, orientation, offset, hollow, a, b);
        if(d > 0,
			d+=2*a-2*b+5;
			b=b-1;
			if(hollow && thick, //to make circles slightly thicker
				positions = positions + fill_flat_circle_points(pos, orientation, offset, hollow, a, b)
			),
			d+=2*a+3
        );
        a+=1;
    );
    positions
);

fill_flat_circle_points(pos, orientation, offset, hollow, a, b) ->(
    [x, y, z] = pos;
    positions = {};
    if(orientation == 'x',
        if(hollow,
            positions += [x + offset, a+y, b+z];
            positions += [x + offset, a+y,-b+z];
            positions += [x + offset,-a+y, b+z];
            positions += [x + offset,-a+y,-b+z];
            positions += [x + offset, b+y, a+z];
            positions += [x + offset, b+y,-a+z];
            positions += [x + offset,-b+y, a+z];
            positions += [x + offset,-b+y,-a+z],
            c_for(c = -a, c<=a, c+=1,
                positions += [x + offset,c+y, b + z];
                positions += [x + offset,c+y,-b + z]
            );
            c_for(c = -b, c<=b, c+=1,
                positions += [x + offset, a+y,c + z];
                positions += [x + offset,-a+y,c + z]
            )
        ),
        orientation=='y',
        if(hollow,
            positions += [ a+x, y + offset, b+z];
            positions += [ a+x, y + offset,-b+z];
            positions += [-a+x, y + offset, b+z];
            positions += [-a+x, y + offset,-b+z];
            positions += [ b+x, y + offset, a+z];
            positions += [ b+x, y + offset,-a+z];
            positions += [-b+x, y + offset, a+z];
            positions += [-b+x, y + offset,-a+z];
			,
            for(range(-b, b+1),
                positions += [ a+x,y + offset,_ + z];
                positions += [-a+x,y + offset,_ + z]
            );
            for(range(-a, a+1),
                positions += [ b+x,y + offset,_ + z];
                positions += [-b+x,y + offset,_ + z]
            )
        ),
        orientation=='z',
        if(hollow,
            positions += [ a+x, b+y, z + offset];
            positions += [ a+x,-b+y, z + offset];
            positions += [-a+x, b+y, z + offset];
            positions += [-a+x,-b+y, z + offset];
            positions += [ b+x, a+y, z + offset];
            positions += [ b+x,-a+y, z + offset];
            positions += [-b+x, a+y, z + offset];
            positions += [-b+x,-a+y, z + offset],
            c_for(c = -a, c<=a, c+=1,
                positions += [c+x, b + y,z + offset];
                positions += [c+x,-b + y,z + offset]
            );
            c_for(c = -b, c<=b, c+=1,
                positions += [ a+x, c + y, z + offset];
                positions += [-a+x, c + y, z + offset]
            )
        )
    );
    positions
);

fill_flat_rectangle(pos, offset, dr, orientation, hollow) -> (
    r = floor(dr);
    drsq = dr^2;
	[x, y, z] = pos;
    positions = {};
    if(orientation == 'x',
        c_for(a = -r, a <=r, a +=1,
            if(hollow,
                positions += [r + offset+x, a+y, r+z];
                positions += [r + offset+x, a+y,-r+z];
                positions += [r + offset+x, r+y, a+z];
                positions += [r + offset+x,-r+y, a+z],
                c_for(b = -r, b <=r, b +=1,
                    positions += [r + offset+x, a+y, b+z]
                )
            )
        ),
        orientation == 'y',
        c_for(a = -r, a <=r, a +=1,
            if(hollow,
                positions += [ r+x, r + offset+y,a+z];
                positions += [-r+x, r + offset+y,a+z];
                positions += [a+x, r + offset+y, r+z];
                positions += [a+x, r + offset+y,-r+z],
                c_for(b = -r, b <=r, b +=1,
                    positions += [a+x, r + offset+y, b+z]
                )
            )
        ),
        orientation == 'z',
        c_for(a = -r, a <=r, a +=1,
             if(hollow,
                positions += [ r+x, a+y,r + offset+z];
                positions += [-r+x, a+y,r + offset+z];
                positions += [a+x, r+y, r + offset+z];
                positions += [a+x,-r+y, r + offset+z],
                c_for(b = -r, b <=r, b +=1,
                    positions += [b+x, a+y, r + offset+z]
                )
            )
        ),
    );
    positions
);
